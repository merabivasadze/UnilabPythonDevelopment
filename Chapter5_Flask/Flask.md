# Flask საწყისები
[ოფიციალური გვერდი](https://palletsprojects.com/p/flask/) | [დოკუმენტაცია](https://flask.palletsprojects.com/en/1.1.x/) | [GitHub](https://github.com/pallets/flask)

![Flask](https://flask.palletsprojects.com/en/1.1.x/_images/flask-logo.png)

ფლასკი Python-ში დაწერილი ვებ მიკრო ფრიმვორკია. Flask-ის გამოყენებით მარტივად და სწრაფად შეგიძლიათ ააწყოთ მარტივი ვებ სერვისები
პითონში და პროექტის გართულებასთან ერთად დახუნძლოთ აპლიკაცია უამრავი შესაძლებლობით, რომელსაც [flask-ის ნაკრებები და third-party
ბიბლიოთეკები გვთავაზობენ](https://www.fullstackpython.com/flask-extensions-plug-ins-related-libraries.html).

## სარჩევი
- [დაყენება](დაყენება)
- [დამატებითი რესურსები](#დამატებითი-რესურსები)
- [მინიმალური აპლიკაციის შაბლონი](#საწყისი-აპლიკაციის-შაბლონი)
- [ტერმინალში გამოტანილი ინფორმაცია](#ტერმინალი)
- [HTTP მეთოდები / რესურსი](#http-მეთოდები)
- [Routing - რესურსის მისამართის აწყობა](#routing)
- [რესურსზე მეთოდის ტიპის დამატება](#რესურსზე-მეთოდის-ტიპის-დამატება)
- [დინამიური მარშუტირება, ცვლადებთან მუშაობა, მისამართიდან პარამეტრის ამოღება](#დინამიური-მარშუტირება)

## დაყენება
### დაყენება pip მენეჯერით

```
pip install flask
```

### დაყენება conda მენეჯერით

```
conda install flask
```


ინსტალაციის წარმატებით დასრულების შესამოწმებლად, ინტერპრეტატორის გამოყენებით სცადეთ ბიბლიოთეკის შემოტანა:


```python
from flask import Flask
```

_თუ ინტერპრეტატორი გეტყოვით რომ flask მოდული ვერ მოიძებნა, ნიშნავს რომ ინსტალაციის საფეხური წარმატებით არ შესრულებულა._

## [საწყისი აპლიკაციის შაბლონი](https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application)

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def home():
    return "<h1>გამარჯობა</h1>"

app.run()
```

კოდი | მნიშვნელობა
---|---
``from flask import Flask`` | ბიბლიოთეკა flask-იდან შემოიტანე Flask კლასი
`app = Flask(__name__)` | ქმნის აპლიკაციის ობიექტს Flask-ის მეშვეობით. გადაცემული ``__name__``-ის მეშვეობით აპლიკაცია საზღვრავს პროგრამის საწყის მებარეობას, რის მიმართაც ეძებს/ტვირთავს დამატებით რესურსებს.
`@app.route('/')` | [route დეკორატორი](#route) რომელიც Fask-ს აწვდის ინფორმაციას თუ რა URL-ზე უნდა გააქტიურდეს მის ქვეშ მდგომი ფუნქცია.
```def home(): return "<h1>გამარჯობა</h1>" ``` | ფუნქცია რომელიც აქტიურდება დეკორატორით განსაზღვრულ მისამართზე, ასრულებს გაწერილ ფუნქციონალს და return-ით აბრუნებს მომხმარებლისთვის საჩვენებელ მონაცემს.
`app.run()` | app ობიექტის run მეთოდის გამოყენებით გაეშვება ჩვენს მიერ აწყობილი Flask აპლიკაცია. (მეთოდის გამოძახებისას შეგიძლიათ გადასცეთ port ცვლაის მნიშნველობა რაც განსაზღვრავს თუ რომელ პორტზე გაეშვება აპლიკაცია)

## ტერმინალი
ინტერნეტ ბრაუზერით ლოკალურ სერვერთან დაკავშირებისას (ჩემს შემთხვევაში მისამართზე: http://127.0.0.1:5000/), საინფორმაციო ველში გამოვა ჩანაწერი "გამარჯობა", ხოლო ტერმინალში შეამჩნევთ
შესაბამის შეტყობინებებს.

     * Serving Flask app "__main__" (lazy loading)
     * Environment: production
       WARNING: This is a development server. Do not use it in a production deployment.
       Use a production WSGI server instead.
     * Debug mode: off
     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
    127.0.0.1 - - [30/Mar/2020 01:31:33] "GET / HTTP/1.1" 200 -
    127.0.0.1 - - [30/Mar/2020 01:31:37] "GET / HTTP/1.1" 200 -
    

## HTTP მეთოდები
![HTTP მეთოდების ტიპები](https://2.bp.blogspot.com/-ATf_71UvxkI/V6iZSnciLLI/AAAAAAAAAfg/FyeGcATjy2UTUiwDT0nRFeB99Mqs1CagQCLcB/s1600/http-14-638.jpg)

_[HyperText Transfer Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)_ -ის მიზანია უზრუნველყოს კომუნიკაცია მომხმარებელსა და სერვერს შორის,
წინასწარ გაწერილი მეთოდების ნაკრებით.

ვებ აპლიკაციის ფუნცქიაა დაამუშავოს ვებ მოთხოვნები. ვებ აპლიკაცია იყენებს სხვადასხვა ტიპის HTTP მოთხოვნებს მომხმარებელთან სასაუბროთ. ყოველი მეთოდის ტიპის მოთხოვნაზე წინასწარ ვწერთ ფუნქციონალს და ვაბამთ
მას შესაბამის მისამართზე.
ვებ საიტზე შესვლისას, სერვერზე გაშვებული პროგრამის ტერმინალის ფანჯარაში გამოჩნდება ინფორმაცია (ლოგი) შემოსული მოთხოვნის შესახებ, მაგ.:

`127.0.0.1 - - [30/Mar/2020 01:31:33] "GET / HTTP/1.1" 200 -`

მოცემული ლოგის სტრუქტურა შემდეგნაირია:

მისამართი - - [თარიღი(დღე/თვე/წელი საათი:წუთი:წამი)] "მეთოდის_ტიპი  მისამართი  პროტოკოლი" სტატუსი -

### HTTP მეთოდების ძირითადი ტიპები:

**GET** - მონაცემის ამოღება
**POST** - მონაცემის მიღება და გამოყენება
**PUT** - მონაცემის შექმნა ან განახლება
**DELETE** - მონაცემის ამოშლა

სერვერის მხარეს ყველა მოთხოვნის ტიპი ერთნაირად მუშავდება თუმცა განსხვავდება თითოეული მეთოდის ფუნქციონალი, იმის მიხედვით თუ რა დავალების შესასრულებლად გაწერს დეველოპერი კონკრეტულ მეთოდს. 
განსხვავებული ტიპები მეთოდები ოპერაციების კატეგორიზაციასა და მოწესრიგებაში გვეხმარება. 
ეს გვაძლევს შესაძლელბლობას ერთ მისამართზე რამოდენიმე სხვადასხვა ტიპის მოთხოვნის განვათავსოთ, რაც რესურსს ქმნის.

## Routing
სერვერზე ვებ-გვერდი გარკვეულ მისამართზეა განთავსებული. იმისთვის რომ მომხმარებელი "მისწვდეს" ამ გვევრდს, მას ესაჭიროება გვერდის მისამართის / urlის ცოდნა.
Flask-ის დახმარებით მარტივად შეძლებთ მომხმარბელისთვის გაწეროთ სასურველი რესურსის მარშუტი route მეთოდის გამოყენებით:

სტანდარტულად, აპლიკაციაში route-ით ახალი მისამართის გაწერისას, ფუნქციონალი რომელსაც დეკორატორის ქვეშ განვათავსებთ GET მეთოდის მოთხოვნაზე მოახდენს რეაგირებას.
სწორედ GET ტიპის მოთხოვნას აგზავნის ბრაუზერი მითითებულ მისამართზე გადასვლისას, შესაბამისად სწორედ ამ მეთოდის ქვეშ უნდა დავაბრუნოთ მომხმარებლისთვის გამოსაჩენი რესურსი,
მაგალითად ვებ-გვერდი. მარშუტის ასაწყობად route მეთოდს პარამეტრად უნდა გადავცეთ რესურსის მისამართი:

```python
@app.route('/')
def index():
    return 'Index Page'

@app.route('/hello')
def hello():
    return 'Hello, World'
```
ამ რიგად route დეკორატორის გამოყენებით ვაბამთ ფუნქციას შესაბამის მისამართს. კონკრეტული მაგალითი შექმნის ორ მარშუტს:
> server_address/
>
> server_address**/hello**

ლოკალურად კომპიუტერზე გაშვებული აპლიკაციის მისამართი იქნება localhost:port ხოლო სერვერისთვი მიიღებს სერვერის მისამართის მნიშვნელობას, მაგალითად mysite.ge .

მიუხედავად იმისა რომ მეთოდის დასახელებას პროგრამის მუშაობისთვის მნიშვნელობა არ აქვს, მეთოდებს **უნდა ერქვათ უნიკალური სახელი**.

### რესურსზე მეთოდის ტიპის დამატება
ერთი როუთზე წვდომის დაშვება შესაძლებელია [სხვადასხვა ტიპის მეთოდისათვის](#http-მეთოდები). ამისთვის route-სთვის გადასაცემ methods-ს პარამეტრს უნდა მივანიჭოთ შესაბამისი მეთოდის დასახელების არგუმენტი, რომელზეც გვინდა რომ ფუნქცია გააქტურდეს.
მაგალითად: ```methods = ['POST', 'GET']```

მარშუტის აწყობის შემდგომ საჭიროა მეთოდის ფუნქციონალის გაწერა. საბოლოოდ რესურსის მეთოდს აქვს მსგავსი სტრუქტურა:


```python
@app.route('/do_something_here', methods = ['POST'])
def do_something_function():
    
    # კოდი რომელიც მეთოდის ფუნქციონალს ასრულებს
    
    return 200, 'ok'
```

200 ok არის [სტატუს კოდი](https://www.flaskapi.org/api-guide/status-codes/) რომელიც მოთხოვნის მხარეს ატყობინებს რომ მოთხოვნა წარმატებით შესრულდა. [ფლასკში ინტეგრირებულ სტატუს კოდებზე დოკუმენტაცია](https://www.flaskapi.org/api-guide/status-codes/)

### დინამიური მარშუტირება
ვებ აპლიკაციებთან მუშაობისას ხშირად წავაწყდებით დინამიურ მისამართებს, რაც გულისხმობს მისამართში ცვლადი პარამეტრების შემოტანას.
მაგალითად დინამიურად შეიძლება ჩაითვალოს მომხმარებლის პროფილის გვერდის მისამართი. 
თუ ყველა პროფილი განთავსებულია მისამართზე _site.ge/profiles_ მომხმარებლებების გვერდს უნდა ველოდოთ _site.ge/profiles/randomuser_ მისამართზე.

შესაბამისად ვიღებთ შაბლონურ მისამართს მომხმარებლისთვის: `'/profiles/<username>`

სწორედ ამ შაბლონურ მისამართს გადავცემთ route მეთოდს დინამიური მარშუტის ასაწყობად. 

`'/profiles/Totoro` მისამართზე გადასვლისას, მისამართში გაწერილი ცვლადი username მიიღებს მნიშვნელობას Totoro. 
მისამართში გაწერილი ცვლადი ( "<>"-ს გარეშე) შეგვიძლია გადავცეთ მეთოდს და გამოვიყენოთ ფუნქციონალში სურვილისამებრ.

```python
@app.route('/profiles/<username>', methods = ['GET'])
def info_classroom(username):
    
    # კოდი ბაზიდან საკლასო ოთახზე ინფორმაციის ამოსაღებად
    
    return classroomInfo
```

#### convertor
სურვილისამებრ შეგიძლიათ გამოიყენოთ ინტეგრირებული კონვერტორი, რომელიც დინამიური მისამართიდან ამოღებულ მნიშვნელობას ცვლადში შეინახავს წინასწარ განსაზღვრულ მონაცემის ტიპად.
ამისთვის უნდა გამოიყენოთ convertor-ის ცვლადის გაწერამდე: `<covertor:variable_name>`

მაგალითად:
```python
@app.route('/profiles/<string:username>')
def show_user_profile(username):
    # მომხმარებლის პროფილის ჩატვირთვა
    return f'User {username}'

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # პოსტის ჩასატვირთად post_id-ის როგორც integer-ის გამოყენება
    return f'Post {post_id}'

@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # ქვე-მისამართის გამოტანა 
    return f'Subpath {subpath}'
```

##### კონვერტორის ტიპები
ტიპი | აღწერა
--- | ---
``string`` | (default) იღებს ნებისმიერ ტექსტს დახრილი ხაზის გარდა
``int``  |  იღებს დადებით მთელ რიცხვებს
``float`` |  იღებს დადებით წილადებს
``path``  | გამოიყენება როგორც ``string`` მაგრამ იღებს დახრილ ხაზს ქვე-მისამართების ამოსაღებად
``uuid``  | იღებს UUID სტრინგს

## Debug Mode
პროექტზე მუშაობისას შეიძლება გაგვეპაროს შეცდომები რომლის პოვნაც და გადაჭრაც გახდება საჭირო.
Flask-ზე მუშაობისას შეგიძლია გააქტიურო debug რეჟიმი რომელიც ახალ შესაძლებლობებს მოგცემს. 
მაგალითად, ყოველი ცვლილებისას არ მოგიწევს აპლიკაციის გამორთვა და თავიდან გაშვება, არც ბრაუზერიდან კონსოლში გადასვლა
პრობლემის ტიპის და მდებარეობის აღმოსაჩენად. იმისთვის რომ Debug რეჟიმის შესაძლებლობები გამოცადო, run მეთოდს უნდა მიუთითო რომ აპლიკაციის დებაგ რეჟიმში გაშვება გსურს:
    
``app.run(debug=True)``

## დამატებითი რესურსები
- [უამრავი Flask-ს მორგებული ბიბლიოთეკა, პლაგინები და რესურსები](https://github.com/humiaozuzu/awesome-flask)
